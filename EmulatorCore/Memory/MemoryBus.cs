using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using EmulatorCore.Components;
using EmulatorCore.Components.Memory;

namespace EmulatorCore.Memory
{
    public class MemoryBus : IEmulatorComponent, IMemoryBus
    {
        #region Private Fields

        private List<MemoryMapping> mappings;
        private List<Mirroring> mirrorings;
        private int width;
        private int size;

        #endregion

        private class Mirroring
        {
            #region Constructor

            internal Mirroring(int sourceStartAddress, int sourceSize, int mirrorStartAddress, int mirrorEndAddress)
            {
                this.SourceStartAddress = sourceStartAddress;
                this.SourceSize = sourceSize;
                this.MirrorStartAddress = mirrorStartAddress;
                this.MirrorEndAddress = mirrorEndAddress;
            }

            #endregion

            #region Properties

            internal int SourceStartAddress;
            internal int SourceSize;
            internal int MirrorStartAddress;
            internal int MirrorEndAddress;

            #endregion
        }

        #region Constructor

        public MemoryBus(int width, string name)
        {
            this.width = width;
            this.Name = name;
            this.size = (int)Math.Pow(2, width);

            this.mappings = new List<MemoryMapping>();
            this.mirrorings = new List<Mirroring>();
        }

        #endregion

        #region IEmulatorComponent Implementation

        public string Name { get; private set; }

        #endregion

        #region Helpers

        private IMemoryMappedDevice GetDeviceAtAddress(ref int address)
        {
            int localAddress = address;
            MemoryMapping mapping = this.mappings.FirstOrDefault(m => m.StartAddress <= localAddress && m.EndAddress >= localAddress);

            if (mapping == null)
            {
                // If we weren't able to find a mapping for the address, check to see if the address is in a mirrored range
                Mirroring mirroring = this.mirrorings.FirstOrDefault(m => m.MirrorStartAddress <= localAddress && m.MirrorEndAddress >= localAddress);
                if (mirroring != null)
                {
                    localAddress = mirroring.SourceStartAddress + ((localAddress - mirroring.MirrorStartAddress) % mirroring.SourceSize);
                    mapping = this.mappings.FirstOrDefault(m => m.StartAddress <= localAddress && m.EndAddress >= localAddress);
                }
            }

            address = localAddress;
            return mapping?.Device;
        }

        #endregion

        #region IMemoryBus Implementation

        IEnumerable<IMemoryMapping> IMemoryBus.Mappings
        {
            get
            {
                return new ReadOnlyCollection<IMemoryMapping>(this.mappings.Cast<IMemoryMapping>().ToList());
            }
        }

        byte IMemoryBus.Read(int address)
        {
            IMemoryMappedDevice device = this.GetDeviceAtAddress(ref address);
            if (device == null)
            {
                Debug.WriteLine("Read of unmapped address 0x{0,8:X8} on bus '{1}'!", address, this.Name);
                return 4; // Uninitialized memory contents, generated by fair dice roll;
            }

            return device.Read(address);
        }

        void IMemoryBus.Write(int address, byte value)
        {
            IMemoryMappedDevice device = this.GetDeviceAtAddress(ref address);
            if (device == null)
            {
                Debug.WriteLine("Write of unmapped address 0x{0:X8} = 0x{1:X2} on bus '{2}'!", address, value, this.Name);
                return;
            }

            device.Write(address, value);
        }

        void IMemoryBus.SetMirroringRange(int sourceStartAddress, int sourceEndAddress, int mirrorStartAddress, int mirrorEndAddress)
        {
            int sourceSize = (sourceEndAddress - sourceStartAddress) + 1;
            int mirrorSize = (mirrorEndAddress - mirrorStartAddress) + 1;
            if (mirrorSize % sourceSize != 0)
            {
                throw new InvalidOperationException("Size of mirrored range must be a multiple of size of source range!");
            }

            this.mirrorings.Add(new Mirroring(sourceStartAddress, sourceSize, mirrorStartAddress, mirrorEndAddress));
        }

        IMemoryMapping IMemoryBus.RegisterMappedDevice(IMemoryMappedDevice device, int address)
        {
            MemoryMapping mapping = new MemoryMapping(device, address, address);
            this.mappings.Add(mapping);
            return mapping;
        }

        IMemoryMapping IMemoryBus.RegisterMappedDevice(IMemoryMappedDevice device, int startAddress, int endAddress)
        {
            MemoryMapping mapping = new MemoryMapping(device, startAddress, endAddress);
            this.mappings.Add(mapping);
            return mapping;
        }

        void IMemoryBus.RemoveMapping(IMemoryMapping mapping)
        {
            this.mappings.Remove((MemoryMapping)mapping);
        }

        #endregion
    }
}
